---
eip: 1337
title: [WIP] Subscriptions on the blockchain.
author: Kevin Owocki <kevin@gitcoin.co> , Andrew Redden <andrew@blockcrushr.com>, Scott Burke <scott@blockcrushr.com> , Kevin Seagraves <k.s.seagraves@gmail.com> , Luka Kacil <luka.kacil@gmail.com>, Štefan Šimec <stefan.simec@gmail.com>, Piotr Kosiński (@kosecki123), ankit raj <tradeninja7@gmail.com>, John Griffin <john@atchai.com> , Nathan Creswell <nathantr@gmail.com>

discussions-to: https://github.com/EthereumOpenSubscriptions/standard/issues or https://gitcoin.co/slack in #proj-subscriptions channel
type: Standards
category: Interface
created: 2018-08-01
requires: ERC-20, ERC-948, EIP-165, EIP-1271
---

<!--You can leave these HTML comments in your merged EIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new EIPs. Note that an EIP number will be assigned by an editor. When opening a pull request to submit your EIP, please use an abbreviated title in the filename, `eip-draft_title_abbrev.md`. The title should be 44 characters or less.-->

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Provide a simplified and layman-accessible explanation of the EIP.-->
Monthly subscriptions are a key monetization channel for legacy web, and arguably they are the most healthy monetization channel for businesses on the legacy web (especially when compared to ad/surveillance) based models.  They are arguably more healthy than a token based economic system (depending upon the vesting model of the ICO) because
#####For a user:
 * you don't have to read a complex whitepaper to use a dapps utility (as opposed to utility tokens)
* you don't have to understand the founder's vesting schedules
* you can cancel anytime

#####For a Service Provider:
* since you know your subscriber numbers, churn numbers, conversion rate, you get consistent cash flow, and accurate projections
* you get to focus on making your customers happy 
* enables you to remove speculators from your ecosystem

For these reasons, we think it's imperative to create a standard way to do 'subscriptions' on Ethereum.

## Abstract
<!--A short (~200 word) description of the technical issue being addressed.-->
To enable replay-able transactions users sign a concatenated bytes hash that is composed of the input data needed to execute the transaction. This data is stored off chain by the recipient of the payment and is transmitted to the customers smart contract for execution alongside a provided signature.

## Motivation
<!--The motivation is critical for EIPs that want to change the Ethereum protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the EIP solves. EIP submissions without sufficient motivation may be rejected outright.-->
Recurring payments are the bedrock of SaSS and countless other businesses, a robust specification for defining this interaction will enable a broad spectrum of revenue generation and business models.

## Specification
<!--The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Ethereum platforms (go-ethereum, parity, cpp-ethereum, ethereumj, ethereumjs, and [others](https://github.com/ethereum/wiki/wiki/Clients)).-->
#### Enum Contract

EIP-1337 Contracts should be compiled with a contract that references all the enumerations that are required for operation

```SOLIDITY
/// @title Enum - Collection of enums
/// Original concept from Richard Meissner - <richard@gnosis.pm> Gnosis safe contracts
contract Enum {
    enum Status {
       INIT,
       TRIAL,
       VALID,
       CANCELLED,
       EXPIRED
    }
    
    enum Period {
        INIT,
        SECOND,
        MINUTE,
        HOUR,
        DAY,
        WEEK,
        BI_WEEKLY,
        MONTH,
        THREE_MONTH,
        SIX_MONTH,
        YEAR,
        TWO_YEAR,
        THREE_YEAR
    }
}
```



#### EIP-165

ERC-948 Compliant contracts support EIP-165 announcing what interfaces they support 

```SOLIDITY
interface ERC165 {
    /**
    * @notice Query if a contract implements an interface
    * @param interfaceID The interface identifier, as specified in ERC-165
    * @dev Interface identification is specified in ERC-165. This function
    * uses less than 30,000 gas.
    * @return `true` if the contract implements `interfaceID` and
    * `interfaceID` is not 0xffffffff, `false` otherwise
    **/
    function supportsInterface(
        bytes4 interfaceID
    ) 
    external 
    view 
    returns (
        bool
    );
}
```



#### Public View Functions

###### isValid
```SOLIDITY

    /** @dev Checks if the subscription is valid.
      * @param bytes32 signatureData is the identifier of the customer's subscription with its relevant details.
      * @param bytes signatures is the signature provided to the merchant to validate the subscription
      * @return success is the result of whether the subscription is valid or not.
      **/
    function isValid(
        bytes signatureData,
        bytes signatures
    ) 
    external 
    view 
    returns (
        bool success
    )
```

###### getHash

```SOLIDITY
    /** @dev returns the hash of concatenated inputs to the address of the contract holding the logic.,
      * the owner would sign this hash and then provide it to the party for execution at a later date,
      * this could be viewed like a cheque, with the exception that unless you specifically
      * capture the hash on chain a valid signature will be executable at a later date, capturing the hash lets you modify the status to cancel or expire it.
      * @param address recipient the address of the person who is getting the funds.
      * @param uint256 value the value of the transaction
      * @param bytes data the data the user is agreeing to
      * @param Enum.period period valid period supported by the spec
      * @param uint256 startDate the start of the agreement (UNIX TIMESTAMP)
      * @param uint256 endDate  the end of the agreement (UNIX TIMESTAMP)
      * @param uint256 uniqueId the unique identifier of the subscription hash, (for more than 1 subscription to the same merchant) 
      * @return bytes32, return the EIP712 compliant hash 
    **/
    function getHash(
        address recipient,
        uint256 value,
        bytes data,
        Enum.Period period,
        uint256 startDate,
        uint256 endDate,
        uint256 uniqueId
    )
    external
    view
    returns (
        bytes32 hash
    )
```


###### getActionHash

```SOLIDITY
    /** @dev returns the hash of concatenated inputs that the owners user would sign with their public keys
    * @param bytes32 the hash to modify 
    * @param uint256 value the value of the transaction
    * @return bytes32 returns the hash of concatenated inputs with the address of the contract holding the subscription hash
    **/
    function getActionHash(
        bytes32 hash
        string action
    )
    public
    view
    returns (
        bytes32 actionHash
    )
```


#### Public Functions


###### execute
```SOLIDITY

    /// @param to Destination of transaction
    /// @param value Ether value 
    /// @param data bytes payload transaction.
    /// @param period uint256 1337 period
    /// @param unique uint256 1337 unique
    /// @param startDate uint256 1337 start
    /// @param endDate uint256 1337 end
    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint256 v})
    /// @return success boolean value of execution
    function execute(
        address to,
        uint256 value,
        bytes memory data,
        uint8 period,
        uint256 startDate,
        uint256 endDate,
        uint256 unique,
        bytes memory signatures
    )
    public
    returns (
        bool paid
    )
```

###### execute
```SOLIDITY

    /** @dev cancel the subscription and check against the actionHash to ensure that its a valid subscription
    * @param bytes32 hash the hash of the subscription that is being cancelled
    * @param bytes signatures the signature proving the users intent to cancel
    * @return bool success something to note that a failed execution will still pay the issuer of the transaction for their gas costs.
    **/
    function cancel(
        bytes32 hash,
        bytes signatures
    )
    public 
    returns (
        bool success
    )
```

## Rationale
<!--The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->
Merchants who accept credit-cards do so by storing a token that is retrieved from a third party processor(stripe, paypal, etc), this token is used to grant access to pull payment from the cx's credit card provider and move funds to the merchant account. 
Having users sign input data acts in a similliar fashion and enables that merchant to store the signature of the concatenated bytes hash and input data used to generate the hash and pass them off to the contract holding the subscription logic, thus enabling a workflow that is similliar to what exists in the present day legacy web.

## Backwards Compatibility
<!--All EIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The EIP must explain how the author proposes to deal with these incompatibilities. EIP submissions without a sufficient backwards compatibility treatise may be rejected outright.-->
N/A

## Test Cases
<!--Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.-->
[WIP]

## Implementation
<!--The implementations must be completed before any EIP is given status "Final", but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of "rough consensus and running code" is still useful when it comes to resolving many discussions of API details.-->
[WIP]

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
